var mkdirp 		= require("mkdirp");
var fs 			= require("fs");
var process 	= require("child_process");
var spawn 		= require("child_process").spawn;
var path 		= require("path");
var Q 			= require("q");

var response = {};
var compiler = {};

var fileStorePath = 'temp-store/'

// Derive code extension from language
var getFileExtension = function(language) {
	switch (language) {
		case 'C':
			return '.c';
			break;
		case 'C++':
			return '.cpp';
			break;
		case 'Java':
			return '.java';
			break;
	}
};

// Form compilation command for different languages
var formCompileCommand = function(dirName, fileName, language, showWarnings) {
	var warningOption = '';
	switch(language) {
		case 'C':
			warningOption = showWarnings ? '-w ' : '';
			return 'gcc '+warningOption+fileStorePath+dirName+'/'+fileName+'.c'+' -o '+'./temp-store/'+dirName+'/'+fileName;
			break;
		case 'C++':
			warningOption = showWarnings ? '-w ' : '';
			return 'g++ '+fileStorePath+dirName+'/'+fileName+'.cpp'+' -o '+'./temp-store/'+dirName+'/'+fileName;
			break;
		case 'Java':
			warningOption = showWarnings ? '-nowarn ' : '';
			return 'javac '+warningOption+fileStorePath+dirName+'/'+fileName+'.java';
			break;
	}
};

// Form execute command for different languages
var formExecuteCommand = function(dirName, fileName, language, argumentsArray) {
	var fileLocation = fileStorePath+dirName+'/'+fileName;

	switch(language) {
		case 'C':
			return fileLocation;
			break;
		case 'C++':
			return fileLocation;
			break;
		case 'Java':
			return 'java';
			break;
	}
}

var formArgumentsArray = function(dirName, fileName, language, argumentsArray) {
	switch(language) {
		case 'C':
			return argumentsArray;
			break;
		case 'C++':
			return argumentsArray;
			break;
		case 'Java':
			argumentsArray.unshift(fileName);
			argumentsArray.unshift('.:'+fileStorePath+dirName);
			argumentsArray.unshift('-cp');
			return argumentsArray;
			break;
	}
};

var writeCodeToFile = function(params, callback) {
	var fileExtension 		= getFileExtension(params.language),
		dirName 			= params.dirName,
		fileName 			= params.fileName+fileExtension,
		code 				= params.code,
		compiledDir 		= fileStorePath+dirName,
		compiledFilePath 	= fileStorePath+dirName+'/'+fileName,
		response 			= {};

	mkdirp(compiledDir, function(mkdirpError) {
		if(mkdirpError) {
			console.log('mkdirpError');
			response = {
				"writeResult" 	: "fail",
				"error" 		: error.toString()
			};
			return callback(response);
		}
		else {
			fs.writeFile(compiledFilePath, code, 'utf-8', function(error) {
				if(error) {
					response = {
						"writeResult" 	: "fail",
						"error" 		: error.toString()
					};
					return callback(response);
				}
				return callback(params);
			});
		}
	});
};

var compileFile = function(params, callback) {
	var compileCommand = formCompileCommand(params.dirName, params.fileName, params.language, params.showWarnings);
	console.log(compileCommand);
	var exec = process.exec(compileCommand, function(error, stdout, stderr) {
		if(error!=null) {
			response = {
				compileResult 	: "fail",
				error 			: error.toString()
			};
		}
		else if(stderr) {
			response = {
				compileResult 	: "fail",
				error 			: stderr.toString()
			};
		}
		else {
			response = {
				"compileResult" : "success"
			};
		}
		return callback(response);
	});
};

compiler.compile = function(params, callback) {
	writeCodeToFile(params, function(writeResponse) {
		// console.log('Write response ', writeResponse);
		compileFile(writeResponse, function(compileResponse) {
			// console.log('Compile response : ', compileResponse);
			return callback(compileResponse);
		});
	});
};

compiler.execute = function(data, socket) {
	var executeCommand 	= formExecuteCommand(data.dirName, data.fileName, data.language, data.arguments),
		arguments 		= formArgumentsArray(data.dirName, data.fileName, data.language, data.arguments)
		myProcess 		= spawn(executeCommand, arguments);
	console.log('Execute : ', executeCommand);
	// Pass input from socket to stdin
	socket.on('input', function(data) {
		console.log('received input : ', data);
		myProcess.stdin.write(data+'\n');
	});

	// Bind process io/err streams to socket.
	myProcess.stdout.setEncoding('utf-8');
	myProcess.stdout.on('data', function (data) {
		console.log('data: ', data);
		socket.emit('output', data);
	});
	myProcess.stderr.setEncoding('utf-8');
	myProcess.stderr.on('data', function (data) {
		socket.emit('output', data);
	});
	myProcess.on('exit', function(code) {
		console.log('myProcess ended with : '+code);
		socket.emit('complete');
		socket.emit('disconnect', 'disconnect');
	});
	// myProcess.on('close', function(code) {
	// 	console.log('myProcess ended with : '+code);
	// 	if(socket) {
	// 		socket.emit('complete');
	// 		socket.emit('disconnect', 'disconnect');
	// 		socket.disconnect();
	// 	}
	// });

	// Infinite loop test function to kill after set timeout.
	// setTimeout(function() {
	// 	myProcess.stdin.pause();
	// 	myProcess.kill();
	// }, 15000);
};

compiler.cleanup = function(dirName) {
	// console.log('Cleaning up dir : ', dirName);
	var cleanupCommand = 'rm -rf '+fileStorePath+dirName;
	var exec = process.exec(cleanupCommand, function(error, stdout, stderr) {
		if(error!=null) {
			console.log('Cleanup failed. Error : ', error);
		}
		else if(stderr) {
			console.log('Cleanup failed. Stderror : ', stderr.toString() );
		}
		else {
			console.log('Cleanup complete');
		}
		return;
	});
};

module.exports = compiler;